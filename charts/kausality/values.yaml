# Default values for kausality

replicaCount: 1

image:
  repository: ghcr.io/kausality-io/kausality
  pullPolicy: IfNotPresent
  tag: ""  # Defaults to appVersion

imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

serviceAccount:
  create: true
  annotations: {}
  name: ""

podAnnotations: {}

podSecurityContext:
  runAsNonRoot: true
  seccompProfile:
    type: RuntimeDefault

securityContext:
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  runAsNonRoot: true

service:
  type: ClusterIP
  port: 443

resources:
  limits:
    cpu: 500m
    memory: 128Mi
  requests:
    cpu: 10m
    memory: 64Mi

nodeSelector: {}

tolerations: []

affinity: {}

# Webhook configuration
webhook:
  # Port the webhook server listens on
  port: 9443
  # Health probe bind address
  healthProbeBindAddress: ":8081"

# Certificate configuration
# cert-manager or self-signed certificates
certificates:
  # Use cert-manager to manage certificates
  certManager:
    enabled: false
    issuerRef:
      name: ""
      kind: Issuer  # or ClusterIssuer
  # Use self-signed certificates (generated by Helm)
  selfSigned:
    enabled: true

# Resource rules for webhook - which resources to intercept
resourceRules:
  include:
    # Example: intercept all apps/v1 resources
    # - apiGroups: ["apps"]
    #   resources: ["*"]
    # Example: intercept specific custom resources
    # - apiGroups: ["example.com"]
    #   resources: ["ekscluster", "nodepools"]
    []
  exclude:
    # Example: exclude ConfigMaps and Secrets
    # - apiGroups: [""]
    #   resources: ["configmaps", "secrets"]
    []

# Namespaces to exclude from drift detection
excludeNamespaces:
  - kube-system
  - kube-public
  - kube-node-lease

# Drift detection mode configuration
# Can be configured globally or per-resource
driftDetection:
  # Global default mode: "log" (allow but warn) or "enforce" (deny unapproved drift)
  defaultMode: log

  # Per-resource overrides (optional)
  # Allows different modes for different API groups/resources
  # Supports namespace lists, namespace selectors, and object selectors
  # overrides:
  #   # Enforce for deployments in production namespace
  #   - apiGroups: ["apps"]
  #     resources: ["deployments"]
  #     namespaces: ["production"]
  #     mode: enforce
  #
  #   # Enforce for all resources in namespaces labeled critical=true
  #   - apiGroups: ["apps"]
  #     resources: ["*"]
  #     namespaceSelector:
  #       matchLabels:
  #         critical: "true"
  #     mode: enforce
  #
  #   # Enforce for configmaps labeled protected=true
  #   - apiGroups: [""]
  #     resources: ["configmaps"]
  #     objectSelector:
  #       matchLabels:
  #         protected: "true"
  #     mode: enforce
  #
  #   # Log mode for custom resources
  #   - apiGroups: ["example.com"]
  #     resources: ["ekscluster"]
  #     mode: log
  overrides: []

# Logging configuration
logging:
  # Log level (debug, info, warn, error)
  level: info
  # Development mode (more verbose)
  development: false

# Drift callback configuration
# When enabled, drift reports are sent to a webhook endpoint
driftCallback:
  # Enable drift callback
  enabled: false
  # URL of the webhook endpoint (required if enabled)
  # Use backend.enabled to deploy the built-in backend
  url: ""
  # CA certificate for TLS verification (optional)
  # Can be provided inline or via existing secret
  ca:
    # Inline CA certificate (PEM format)
    cert: ""
    # Or use existing secret
    existingSecret: ""
    # Key in the secret to use (default: ca.crt)
    # Use "tls.crt" for cert-manager secrets
    key: "ca.crt"
  # Request timeout
  timeout: 10s
  # Retry configuration
  retryCount: 3
  retryInterval: 1s

# Backend deployment for receiving drift reports
# Deploys kausality-backend-log which logs DriftReports as YAML
backend:
  enabled: false

  replicaCount: 1

  image:
    repository: ghcr.io/kausality-io/kausality-backend-log
    pullPolicy: IfNotPresent
    tag: ""  # Defaults to appVersion

  service:
    type: ClusterIP
    port: 8080

  # Extra arguments to pass to the backend
  extraArgs: []
  # - --some-flag=value

  # Extra environment variables
  extraEnv: []
  # - name: MY_VAR
  #   value: "my-value"

  # Extra environment variables from secrets/configmaps
  extraEnvFrom: []
  # - secretRef:
  #     name: my-secret

  # Extra volume mounts
  extraVolumeMounts: []
  # - name: my-secret
  #   mountPath: /etc/my-secret
  #   readOnly: true

  # Extra volumes
  extraVolumes: []
  # - name: my-secret
  #   secret:
  #     secretName: my-secret

  resources:
    limits:
      cpu: 100m
      memory: 64Mi
    requests:
      cpu: 10m
      memory: 32Mi

  podAnnotations: {}
  nodeSelector: {}
  tolerations: []
  affinity: {}
